import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input, ViewEncapsulation, } from '@angular/core';
import { MatDatepickerIntl } from '@angular/material/datepicker';
import { asyncScheduler, merge, scheduled, Subscription } from 'rxjs';
import { MatDatetimepickerComponent } from './datetimepicker';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/datepicker";
import * as i2 from "@angular/common";
import * as i3 from "@angular/material/button";
import * as i4 from "@angular/material/icon";
export class MatDatetimepickerToggleComponent {
    constructor(_intl, _changeDetectorRef) {
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._stateChanges = Subscription.EMPTY;
    }
    /** Whether the toggle button is disabled. */
    get disabled() {
        return this._disabled === undefined
            ? this.datetimepicker.disabled
            : !!this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    ngOnChanges(changes) {
        if (changes.datepicker) {
            this._watchStateChanges();
        }
    }
    ngOnDestroy() {
        this._stateChanges.unsubscribe();
    }
    ngAfterContentInit() {
        this._watchStateChanges();
    }
    _open(event) {
        if (this.datetimepicker && !this.disabled) {
            this.datetimepicker.open();
            event.stopPropagation();
        }
    }
    _watchStateChanges() {
        const datepickerDisabled = this.datetimepicker
            ? this.datetimepicker._disabledChange
            : scheduled([], asyncScheduler);
        const inputDisabled = this.datetimepicker && this.datetimepicker._datepickerInput
            ? this.datetimepicker._datepickerInput._disabledChange
            : scheduled([], asyncScheduler);
        this._stateChanges.unsubscribe();
        this._stateChanges = merge(this._intl.changes, datepickerDisabled, inputDisabled).subscribe(() => this._changeDetectorRef.markForCheck());
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.4", ngImport: i0, type: MatDatetimepickerToggleComponent, deps: [{ token: i1.MatDatepickerIntl }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    /** @nocollapse */ static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.4", type: MatDatetimepickerToggleComponent, selector: "mat-datetimepicker-toggle", inputs: { datetimepicker: ["for", "datetimepicker"], disabled: "disabled" }, host: { listeners: { "click": "_open($event)" }, classAttribute: "mat-datetimepicker-toggle" }, exportAs: ["matDatetimepickerToggle"], usesOnChanges: true, ngImport: i0, template: "<button\n  [attr.aria-label]=\"_intl.openCalendarLabel\"\n  [disabled]=\"disabled\"\n  mat-icon-button\n  type=\"button\"\n>\n  <mat-icon [ngSwitch]=\"datetimepicker.type\">\n    <svg\n      *ngSwitchCase=\"'time'\"\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path\n        d=\"M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\"\n      ></path>\n    </svg>\n    <svg\n      *ngSwitchCase=\"'datetime'\"\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path\n        d=\"M15,13H16.5V15.82L18.94,17.23L18.19,18.53L15,16.69V13M19,8H5V19H9.67C9.24,18.09 9,17.07 9,16A7,7 0 0,1 16,9C17.07,9 18.09,9.24 19,9.67V8M5,21C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H6V1H8V3H16V1H18V3H19A2,2 0 0,1 21,5V11.1C22.24,12.36 23,14.09 23,16A7,7 0 0,1 16,23C14.09,23 12.36,22.24 11.1,21H5M16,11.15A4.85,4.85 0 0,0 11.15,16C11.15,18.68 13.32,20.85 16,20.85A4.85,4.85 0 0,0 20.85,16C20.85,13.32 18.68,11.15 16,11.15Z\"\n      ></path>\n    </svg>\n    <svg\n      *ngSwitchDefault\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path\n        d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"\n      />\n    </svg>\n  </mat-icon>\n</button>\n", dependencies: [{ kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i2.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: i3.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.4", ngImport: i0, type: MatDatetimepickerToggleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mat-datetimepicker-toggle', host: {
                        class: 'mat-datetimepicker-toggle',
                        // Bind the `click` on the host, rather than the inner `button`, so that we can call `stopPropagation`
                        // on it without affecting the user's `click` handlers. We need to stop it so that the input doesn't
                        // get focused automatically by the form field (See https://github.com/angular/components/pull/21856).
                        '(click)': '_open($event)',
                    }, exportAs: 'matDatetimepickerToggle', encapsulation: ViewEncapsulation.None, preserveWhitespaces: false, changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  [attr.aria-label]=\"_intl.openCalendarLabel\"\n  [disabled]=\"disabled\"\n  mat-icon-button\n  type=\"button\"\n>\n  <mat-icon [ngSwitch]=\"datetimepicker.type\">\n    <svg\n      *ngSwitchCase=\"'time'\"\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path\n        d=\"M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\"\n      ></path>\n    </svg>\n    <svg\n      *ngSwitchCase=\"'datetime'\"\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path\n        d=\"M15,13H16.5V15.82L18.94,17.23L18.19,18.53L15,16.69V13M19,8H5V19H9.67C9.24,18.09 9,17.07 9,16A7,7 0 0,1 16,9C17.07,9 18.09,9.24 19,9.67V8M5,21C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H6V1H8V3H16V1H18V3H19A2,2 0 0,1 21,5V11.1C22.24,12.36 23,14.09 23,16A7,7 0 0,1 16,23C14.09,23 12.36,22.24 11.1,21H5M16,11.15A4.85,4.85 0 0,0 11.15,16C11.15,18.68 13.32,20.85 16,20.85A4.85,4.85 0 0,0 20.85,16C20.85,13.32 18.68,11.15 16,11.15Z\"\n      ></path>\n    </svg>\n    <svg\n      *ngSwitchDefault\n      fill=\"currentColor\"\n      focusable=\"false\"\n      height=\"100%\"\n      style=\"vertical-align: top\"\n      viewBox=\"0 0 24 24\"\n      width=\"100%\"\n    >\n      <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path\n        d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"\n      />\n    </svg>\n  </mat-icon>\n</button>\n" }]
        }], ctorParameters: () => [{ type: i1.MatDatepickerIntl }, { type: i0.ChangeDetectorRef }], propDecorators: { datetimepicker: [{
                type: Input,
                args: ['for']
            }], disabled: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWVwaWNrZXItdG9nZ2xlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvZGF0ZXRpbWVwaWNrZXIvZGF0ZXRpbWVwaWNrZXItdG9nZ2xlLnRzIiwiLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvZGF0ZXRpbWVwaWNrZXIvZGF0ZXRpbWVwaWNrZXItdG9nZ2xlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFJTCxpQkFBaUIsR0FDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDakUsT0FBTyxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7O0FBaUI5RCxNQUFNLE9BQU8sZ0NBQWdDO0lBUTNDLFlBQ1MsS0FBd0IsRUFDdkIsa0JBQXFDO1FBRHRDLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3ZCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFKdkMsa0JBQWEsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDO0lBS3hDLENBQUM7SUFJSiw2Q0FBNkM7SUFDN0MsSUFDSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVM7WUFDakMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUTtZQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQUksUUFBUSxDQUFDLEtBQWM7UUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQVk7UUFDaEIsSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQzFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDM0IsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQzFCLENBQUM7SUFDSCxDQUFDO0lBRU8sa0JBQWtCO1FBQ3hCLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGNBQWM7WUFDNUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZTtZQUNyQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUNsQyxNQUFNLGFBQWEsR0FDakIsSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLGdCQUFnQjtZQUN6RCxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlO1lBQ3RELENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRXBDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUNsQixrQkFBa0IsRUFDbEIsYUFBYSxDQUNkLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQzVELENBQUM7aUlBL0RVLGdDQUFnQztxSEFBaEMsZ0NBQWdDLDBTQy9CN0MsaXhEQWlEQTs7MkZEbEJhLGdDQUFnQztrQkFmNUMsU0FBUzsrQkFDRSwyQkFBMkIsUUFFL0I7d0JBQ0osS0FBSyxFQUFFLDJCQUEyQjt3QkFDbEMsc0dBQXNHO3dCQUN0RyxvR0FBb0c7d0JBQ3BHLHNHQUFzRzt3QkFDdEcsU0FBUyxFQUFFLGVBQWU7cUJBQzNCLFlBQ1MseUJBQXlCLGlCQUNwQixpQkFBaUIsQ0FBQyxJQUFJLHVCQUNoQixLQUFLLG1CQUNULHVCQUF1QixDQUFDLE1BQU07c0hBT2pDLGNBQWM7c0JBQTNCLEtBQUs7dUJBQUMsS0FBSztnQkFZUixRQUFRO3NCQURYLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGF0ZXBpY2tlckludGwgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kYXRlcGlja2VyJztcbmltcG9ydCB7IGFzeW5jU2NoZWR1bGVyLCBtZXJnZSwgc2NoZWR1bGVkLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE1hdERhdGV0aW1lcGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRldGltZXBpY2tlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1kYXRldGltZXBpY2tlci10b2dnbGUnLFxuICB0ZW1wbGF0ZVVybDogJ2RhdGV0aW1lcGlja2VyLXRvZ2dsZS5odG1sJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbWF0LWRhdGV0aW1lcGlja2VyLXRvZ2dsZScsXG4gICAgLy8gQmluZCB0aGUgYGNsaWNrYCBvbiB0aGUgaG9zdCwgcmF0aGVyIHRoYW4gdGhlIGlubmVyIGBidXR0b25gLCBzbyB0aGF0IHdlIGNhbiBjYWxsIGBzdG9wUHJvcGFnYXRpb25gXG4gICAgLy8gb24gaXQgd2l0aG91dCBhZmZlY3RpbmcgdGhlIHVzZXIncyBgY2xpY2tgIGhhbmRsZXJzLiBXZSBuZWVkIHRvIHN0b3AgaXQgc28gdGhhdCB0aGUgaW5wdXQgZG9lc24ndFxuICAgIC8vIGdldCBmb2N1c2VkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGZvcm0gZmllbGQgKFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jb21wb25lbnRzL3B1bGwvMjE4NTYpLlxuICAgICcoY2xpY2spJzogJ19vcGVuKCRldmVudCknLFxuICB9LFxuICBleHBvcnRBczogJ21hdERhdGV0aW1lcGlja2VyVG9nZ2xlJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNYXREYXRldGltZXBpY2tlclRvZ2dsZUNvbXBvbmVudDxEPlxuICBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95XG57XG4gIC8qKiBEYXRlcGlja2VyIGluc3RhbmNlIHRoYXQgdGhlIGJ1dHRvbiB3aWxsIHRvZ2dsZS4gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KCdmb3InKSBkYXRldGltZXBpY2tlcjogTWF0RGF0ZXRpbWVwaWNrZXJDb21wb25lbnQ8RD47XG4gIHByaXZhdGUgX3N0YXRlQ2hhbmdlcyA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgX2ludGw6IE1hdERhdGVwaWNrZXJJbnRsLFxuICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHRvZ2dsZSBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPT09IHVuZGVmaW5lZFxuICAgICAgPyB0aGlzLmRhdGV0aW1lcGlja2VyLmRpc2FibGVkXG4gICAgICA6ICEhdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXMuZGF0ZXBpY2tlcikge1xuICAgICAgdGhpcy5fd2F0Y2hTdGF0ZUNoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl93YXRjaFN0YXRlQ2hhbmdlcygpO1xuICB9XG5cbiAgX29wZW4oZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0ZXRpbWVwaWNrZXIgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGF0ZXRpbWVwaWNrZXIub3BlbigpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfd2F0Y2hTdGF0ZUNoYW5nZXMoKSB7XG4gICAgY29uc3QgZGF0ZXBpY2tlckRpc2FibGVkID0gdGhpcy5kYXRldGltZXBpY2tlclxuICAgICAgPyB0aGlzLmRhdGV0aW1lcGlja2VyLl9kaXNhYmxlZENoYW5nZVxuICAgICAgOiBzY2hlZHVsZWQoW10sIGFzeW5jU2NoZWR1bGVyKTtcbiAgICBjb25zdCBpbnB1dERpc2FibGVkID1cbiAgICAgIHRoaXMuZGF0ZXRpbWVwaWNrZXIgJiYgdGhpcy5kYXRldGltZXBpY2tlci5fZGF0ZXBpY2tlcklucHV0XG4gICAgICAgID8gdGhpcy5kYXRldGltZXBpY2tlci5fZGF0ZXBpY2tlcklucHV0Ll9kaXNhYmxlZENoYW5nZVxuICAgICAgICA6IHNjaGVkdWxlZChbXSwgYXN5bmNTY2hlZHVsZXIpO1xuXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzID0gbWVyZ2UoXG4gICAgICB0aGlzLl9pbnRsLmNoYW5nZXMsXG4gICAgICBkYXRlcGlja2VyRGlzYWJsZWQsXG4gICAgICBpbnB1dERpc2FibGVkXG4gICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCkpO1xuICB9XG59XG4iLCI8YnV0dG9uXG4gIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwub3BlbkNhbGVuZGFyTGFiZWxcIlxuICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICBtYXQtaWNvbi1idXR0b25cbiAgdHlwZT1cImJ1dHRvblwiXG4+XG4gIDxtYXQtaWNvbiBbbmdTd2l0Y2hdPVwiZGF0ZXRpbWVwaWNrZXIudHlwZVwiPlxuICAgIDxzdmdcbiAgICAgICpuZ1N3aXRjaENhc2U9XCIndGltZSdcIlxuICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246IHRvcFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xMiwyMEE4LDggMCAwLDAgMjAsMTJBOCw4IDAgMCwwIDEyLDRBOCw4IDAgMCwwIDQsMTJBOCw4IDAgMCwwIDEyLDIwTTEyLDJBMTAsMTAgMCAwLDEgMjIsMTJBMTAsMTAgMCAwLDEgMTIsMjJDNi40NywyMiAyLDE3LjUgMiwxMkExMCwxMCAwIDAsMSAxMiwyTTEyLjUsN1YxMi4yNUwxNywxNC45MkwxNi4yNSwxNi4xNUwxMSwxM1Y3SDEyLjVaXCJcbiAgICAgID48L3BhdGg+XG4gICAgPC9zdmc+XG4gICAgPHN2Z1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIidkYXRldGltZSdcIlxuICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246IHRvcFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xNSwxM0gxNi41VjE1LjgyTDE4Ljk0LDE3LjIzTDE4LjE5LDE4LjUzTDE1LDE2LjY5VjEzTTE5LDhINVYxOUg5LjY3QzkuMjQsMTguMDkgOSwxNy4wNyA5LDE2QTcsNyAwIDAsMSAxNiw5QzE3LjA3LDkgMTguMDksOS4yNCAxOSw5LjY3VjhNNSwyMUMzLjg5LDIxIDMsMjAuMSAzLDE5VjVDMywzLjg5IDMuODksMyA1LDNINlYxSDhWM0gxNlYxSDE4VjNIMTlBMiwyIDAgMCwxIDIxLDVWMTEuMUMyMi4yNCwxMi4zNiAyMywxNC4wOSAyMywxNkE3LDcgMCAwLDEgMTYsMjNDMTQuMDksMjMgMTIuMzYsMjIuMjQgMTEuMSwyMUg1TTE2LDExLjE1QTQuODUsNC44NSAwIDAsMCAxMS4xNSwxNkMxMS4xNSwxOC42OCAxMy4zMiwyMC44NSAxNiwyMC44NUE0Ljg1LDQuODUgMCAwLDAgMjAuODUsMTZDMjAuODUsMTMuMzIgMTguNjgsMTEuMTUgMTYsMTEuMTVaXCJcbiAgICAgID48L3BhdGg+XG4gICAgPC9zdmc+XG4gICAgPHN2Z1xuICAgICAgKm5nU3dpdGNoRGVmYXVsdFxuICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246IHRvcFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgPlxuICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTE5IDNoLTFWMWgtMnYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOGgxNHYxMXpNNyAxMGg1djVIN3pcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgPC9tYXQtaWNvbj5cbjwvYnV0dG9uPlxuIl19